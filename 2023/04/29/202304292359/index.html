<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RabbitMQ学习笔记 | 陆柒</title><meta name="author" content="Thirteen"><meta name="copyright" content="Thirteen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="消息队列MQ的相关概念什么是MQMQ(message queue),从字面意思上看，本质是个队列，FIFI先进先出，只不过队列中存放的内容是message而已，还是一种跨进程的通信机制，用于上下游传递消息。使用MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。 为什么使用MQ 流量消峰 应对流量高峰期时，服务处理能力有限，对于多出的数据无法处理，而使用消息队列作为缓冲，则可对数据缓存至消息队">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ学习笔记">
<meta property="og:url" content="http://blog.oinbo.cn/2023/04/29/202304292359/index.html">
<meta property="og:site_name" content="陆柒">
<meta property="og:description" content="消息队列MQ的相关概念什么是MQMQ(message queue),从字面意思上看，本质是个队列，FIFI先进先出，只不过队列中存放的内容是message而已，还是一种跨进程的通信机制，用于上下游传递消息。使用MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。 为什么使用MQ 流量消峰 应对流量高峰期时，服务处理能力有限，对于多出的数据无法处理，而使用消息队列作为缓冲，则可对数据缓存至消息队">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-04-29T23:59:21.000Z">
<meta property="article:modified_time" content="2024-11-19T08:25:35.572Z">
<meta property="article:author" content="Thirteen">
<meta property="article:tag" content="RabbitMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.oinbo.cn/2023/04/29/202304292359/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RabbitMQ学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">陆柒</span></a><a class="nav-page-title" href="/"><span class="site-name">RabbitMQ学习笔记</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">RabbitMQ学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-29T23:59:21.000Z" title="发表于 2023-04-29 23:59:21">2023-04-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-19T08:25:35.572Z" title="更新于 2024-11-19 08:25:35">2024-11-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/RabbitMQ/">RabbitMQ</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="MQ的相关概念"><a href="#MQ的相关概念" class="headerlink" title="MQ的相关概念"></a>MQ的相关概念</h2><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><p>MQ(message queue),从字面意思上看，本质是个队列，FIFI先进先出，只不过队列中存放的内容是message而已，还是一种跨进程的通信机制，用于上下游传递消息。使用MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。</p>
<h3 id="为什么使用MQ"><a href="#为什么使用MQ" class="headerlink" title="为什么使用MQ"></a>为什么使用MQ</h3><ul>
<li><p>流量消峰</p>
<p>应对流量高峰期时，服务处理能力有限，对于多出的数据无法处理，而使用消息队列作为缓冲，则可对数据缓存至消息队列以达到消峰。</p>
</li>
<li><p>应用解耦</p>
<p>例如电商系统中，包含有订单、库存、物流等系统，订单创建后需要对其他服务进行数据处理，如果耦合严重，当其中一个节点出现问题时都会导致订单失败。当转为消息队列的方式后，系统间的调用会减少很多，当其中一个系统故障时，将消息放在消息队列中，等故障服务恢复后，对队列中的消息进行消费处理即可。</p>
</li>
<li><p>异步处理</p>
<p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可 以执行完。使用消息队列时可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此 消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不 用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p>
<span id="more"></span></li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="RabbitMQ的概念"><a href="#RabbitMQ的概念" class="headerlink" title="RabbitMQ的概念"></a>RabbitMQ的概念</h3><p>RabbitMQ 是一个消息中间件：它接受并转发消息。</p>
<p>你可以把它当做一个快递站点，当你要发送一个包 裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑 RabbitMQ 是 一个快递站，一个快递员帮你传递快件。</p>
<p>RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收， 存储和转发消息数据。</p>
<h3 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h3><ul>
<li><p>生产者</p>
<p> 生产者时候产生数据的并对消息进行发送的程序。</p>
</li>
<li><p>消费者</p>
<p>消费者是对消息进行接收，大多时候处于等待接收消息的程序</p>
<p>注：消费 者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。</p>
</li>
<li><p>交换机</p>
<p>交换机是 RabbitMQ 非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息 推送到队列中。</p>
</li>
<li><p>队列</p>
<p>队列是 RabbitMQ 内部使用的一种数据结构，尽管消息流经 RabbitMQ 和应用程序，但它们只能存 储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。</p>
<p>许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。</p>
</li>
</ul>
<h3 id="RabbitMQ核心部分"><a href="#RabbitMQ核心部分" class="headerlink" title="RabbitMQ核心部分"></a>RabbitMQ核心部分</h3><p><img src="https://s2.loli.net/2023/05/02/z7YhZMnPGp9Firf.png" alt="核心部分"></p>
<h3 id="各个名词介绍"><a href="#各个名词介绍" class="headerlink" title="各个名词介绍"></a>各个名词介绍</h3><p><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server 就是 Message Broker</p>
<p><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似 于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出 多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</p>
<p><strong>Connection</strong>：publisher／consumer 和 broker 之间的 TCP 连接</p>
<p><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP  Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程 序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客 户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销</strong></p>
<p><strong>Exchange</strong>：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发 消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout  (multicast)</p>
<p><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走</p>
<p><strong>Binding</strong>：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key，Binding 信息被保 存到 exchange 中的查询表中，用于 message 的分发依据</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用docker安装测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">官网 https://www.rabbitmq.com/download.html</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">latest RabbitMQ 3.11</span></span><br><span class="line">docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.11-management</span><br></pre></td></tr></table></figure>



<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p><img src="https://s2.loli.net/2023/05/04/PwMXOxAJtIdf9Nh.png" alt="结构图"></p>
<p>HelloWorld即为简单模式，只需创建队列即可进行消息的发送。</p>
<p><a href="https://github.com/HuangBoo461/rabbimq/tree/master/rabbitmq-hello/src/main/java/net/oiyou/rabbitmq/one">代码实现详见</a></p>
<h1 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h1><p>工作队列(又称任务队列)的主要思想是避免立即执行资源密集型任务，而不得不等待它完成。 相反我们安排任务在之后执行。当消息发送到队列后，所有消费者轮训对消息进行消费。</p>
<h2 id="轮训分发消息"><a href="#轮训分发消息" class="headerlink" title="轮训分发消息"></a>轮训分发消息</h2><p><a href="https://github.com/HuangBoo461/rabbimq/tree/master/rabbitmq-hello/src/main/java/net/oiyou/rabbitmq/two">代码示例详见</a></p>
<p>执行结果可以看出，消费者在轮训对消息进行消费。</p>
<h2 id="消息应道"><a href="#消息应道" class="headerlink" title="消息应道"></a>消息应道</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​		正常情况下，消费者在收到消息后对数据进行处理都是需要花费时间的，倘若在执行过程中突然服务异常，会导致消息丢失。在前面实例下消息是自动确认的，显然不适用。</p>
<p>​		为了保证消息在发送过程中不丢失，rabbitMQ引入了消息应答机制，，消息应答就是：消费者在接收到消息并且处理该消息之后，需要告诉rabbitMQ它已经处理了，可以把消息删除，继续发送后续消息。</p>
<h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><p>​		消息发送后立即被认为已经传送成功，，这种模式<strong>需要在高吞吐量与数据传输安全性方面做权衡</strong>，因为这种模式如果消息在接收到之前，，消费者那边出现连接或者channe关闭，就会导致消息丢失，当然另一方面这种模式消费者那边可以传递过载的消息，<strong>没有对传递到的消息数量进行限制</strong>，这样可能会使得笑得这这边由于接收太多还来不及处理消息。导致消息积压，使得内存上涨，若导致内存耗尽，最终这些消费者线程会被操作系统杀死，，所以这种模式仅<strong>适用于消费者可以高效并以某种速率能够处理这些消息的情况下使用</strong>。</p>
<h3 id="消息应答的方法"><a href="#消息应答的方法" class="headerlink" title="消息应答的方法"></a>消息应答的方法</h3><ul>
<li><p>Channel.basicAck(用于消息肯定确认)</p>
<p>RabbitMQ已知道消息并且成功处理，可以将其丢弃了</p>
</li>
<li><p>Channel.basicNack(用于消息否定确认)</p>
</li>
<li><p>Channel.basicReject(用于消息否定确认)</p>
<p>与Channel.basicNack相比少一个参数，</p>
<p>不处理该消息了直接拒绝，可以将其丢弃了</p>
</li>
</ul>
<h3 id="Multiple的解释"><a href="#Multiple的解释" class="headerlink" title="Multiple的解释"></a>Multiple的解释</h3><p><img src="https://s2.loli.net/2023/05/04/h4YDbKgRaV39Ll6.png" alt="Multiple"></p>
<p>multiple 的 true 和 false 代表不同意思 </p>
<p>true 代表批量应答 channel 上未应答的消息</p>
<p>​	比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时 5-8 的这些还未应答的消息都会被确认收到消息应答 </p>
<p>false </p>
<p>​	同上面相比 只会应答 tag&#x3D;8 的消息 5,6,7 这三个消息依然不会被确认收到消息应</p>
<h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3><p>​		倘若消费者由于某些原因失去连接(通道关闭，，连接已关闭或者TCP连接丢失)，导致消息未发送ACK确认，RabbitMQ 将了解到消息未完全处理，并将对其重新排队。如果此时其他消费者 可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确 保不会丢失任何消息。</p>
<p><img src="https://s2.loli.net/2023/05/04/Gr7jFWwQAbo3x1P.png" alt="消息自动重新入队"></p>
<h3 id="消息手动应答代码"><a href="#消息手动应答代码" class="headerlink" title="消息手动应答代码"></a>消息手动应答代码</h3><p><a href="https://github.com/HuangBoo461/rabbimq/tree/master/rabbitmq-hello/src/main/java/net/oiyou/rabbitmq/three">代码逻辑参考</a></p>
<h3 id="手动应答结果说明"><a href="#手动应答结果说明" class="headerlink" title="手动应答结果说明"></a>手动应答结果说明</h3><p>正常情况下rabbitmq会把消息以轮训的方式分发给各个消费者节点，而第二个消费者增加延时时间较长，当第二个消费者断开连接后，消息还未进行确认，所以会重新入队，由其他节点进行消费。</p>
<h2 id="RabbitMQ持久化"><a href="#RabbitMQ持久化" class="headerlink" title="RabbitMQ持久化"></a>RabbitMQ持久化</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>​		前面通过手动应答的方式保证未确认的消息可以重新入队消费，RabbitMQ数据默认是保存在内存中的，如果不进行初持久化保存，当rRabbittMQ服务异常时，会导致消息的丢失，所以我们需要<strong>将队列和消息都标记为持久化</strong>。</p>
<h3 id="队列实现持久化"><a href="#队列实现持久化" class="headerlink" title="队列实现持久化"></a>队列实现持久化</h3><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的话，该队列就会被删除掉，</p>
<p>如果要队列实现持久化 需要在声明队列的时候把 durable 参数设置为持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//durable值为true时代表持久化</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">durable</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">channel.queueDeclare(TASK_QUEUE_NAME,durable,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>注：如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新 创建一个持久化的队列，不然就会出现错误</p>
<h3 id="消息实现持久化"><a href="#消息实现持久化" class="headerlink" title="消息实现持久化"></a>消息实现持久化</h3><p>要想让消息实现持久化需要在消息发送时在生产者修改代码，，MessageProperties.PERSISTENT_TEXT_PLAIN添加这个属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//生产者发送消息为持久化消息(要求保存到磁盘上)，不设置时默认保存在内存中</span><br><span class="line">channel.basicPublish(&quot;&quot;,TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN,message.getBytes(&quot;UTF-8&quot;));</span><br></pre></td></tr></table></figure>

<h3 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h3><p>​		在开始的时候可以了解到RabbitMQ分发消息使用大的是轮询的方式，但是在某种场景下这种策略并不是很好，比如有两个消费者在处理任务，且其中一个消费者1处理任务非常快，而另一个消费者2处理速度非常慢，这个时候如果还是采用轮训分发的方式消费者1就会有很大一部分时间处于空闲状态，而消费者2则一直在处理，但是RabbitMQ并不知道这种情况，它依然很公平的进行分发</p>
<p>​		为了避免这种情况，我们可以设置参数化channel.basicQos(1);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置不公平分发</span></span><br><span class="line"><span class="type">int</span> <span class="variable">prefetchCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">channel.basicQos(prefetchCount);</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/05/05/3FeyPbDlKR4MXH5.png" alt="不公平分发"></p>
<p>​		意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，我目前只能处理一个任务，然后rabbitmq就会把任务分配给其他没那么忙的空闲消费者，当然如果所有的消费者都没有完成手上的任务，队列还在不停的添加新任务，队列有可能会遇到队列被撑破的情况，这时候就只能添加新的worker还活着改变其他存储任务的策略。</p>
<h3 id="预取值"><a href="#预取值" class="headerlink" title="预取值"></a>预取值</h3><p>​		本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息，另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以通过使用 basicQos 方法设置“预取计数”值来完成的。<strong>该值定义通道上允许的未确认消息的最大数量</strong>。</p>
<p>​		一旦数量达到配置的数量， RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认。</p>
<p>​		例如，假设在通道上有 未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不会在该通道上再传递任何 消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知 这个情况到并再发送一条消息。</p>
<p>​		消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理 的消息的数量也会增加，从而增加了消费者的 RAM 消耗</strong>(随机存取存储器)，应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的 内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范 围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为 1 是最保守的。当然这 将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境 中。对于大多数应用来说，稍微高一点的值将是最佳的。</p>
<p><img src="https://s2.loli.net/2023/05/05/RNAy6gGFltmhfMH.png" alt="预取值"></p>
<h1 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h1><h2 id="发布确认原理"><a href="#发布确认原理" class="headerlink" title="发布确认原理"></a>发布确认原理</h2><p>​		生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID(从1开始)，一旦消息被投递到所匹配的队列，brocker就会发送一个确认给生产者(包含消息的唯一ID)，这使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，brocker回传给生产者的确认晓曦总delivery-tag域包含了确认消息的序列号，此外也可以设置basic.ack的mutiple域，表示这个序列号之前的所有消息都可以得到了处理。</p>
<p>​		confirm模式最大的好处在于他是异步的一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时发送下一条消息，，当消息最终的到确认后，生产者应用便可以通过回调方法来处理该确认消息，，如果RabbitMQ因为自身内部原因导致消息丢失，，就会发送一条nack消息，生产者应用程序同样可以在回调方法中处理该nack消息。</p>
<h2 id="发布确认策略"><a href="#发布确认策略" class="headerlink" title="发布确认策略"></a>发布确认策略</h2><h3 id="开启发布确认的方法"><a href="#开启发布确认的方法" class="headerlink" title="开启发布确认的方法"></a>开启发布确认的方法</h3><p>​		发布确认默认是没有开启的，如果需要开启需要调用方法confirmSelect,每当你要想使用发布确认，，都需要在channel上调用该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">channel..confirmSelect();</span><br></pre></td></tr></table></figure>

<h3 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h3><p>​		这是一种简单的确认方式，是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，，waitFormConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，，如果在指定时间范围内这个消息没被确认那么它将抛出异常。</p>
<p>​		这种方式的最大缺点是：发布速度特别的慢，因为如果没有确认发布的消息会阻塞所有后续消息的发布，最多提供每秒不超过数百条发布消息的吞吐量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageSingleConfirm</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtil.getChannel();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;发送&quot;</span> + i + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;单发布确认模式下发送&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个消耗时&quot;</span> + (end - begin) + <span class="string">&quot;MS&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h3><p>​		单个确认发布的方式非常慢，与单个等待确认相比，先发布一批消息。。然后一起确认可以极大地提高吞吐量，当然这种方式的缺点是：当发生故障导致消息发布出现问题时，不知道哪个消息出现问题必须将整个批处理保存在内存中，，以记录重要的消息而后重新发布消息。当然这种方式仍然是同步的，也一样会阻塞消息的发布。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtil.getChannel();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">            <span class="keyword">if</span>(i % batchSize == <span class="number">99</span>)&#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;发送至&quot;</span> + i + <span class="string">&quot;成功&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;批量发布确认模式下发送&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个消耗时&quot;</span> + (end - begin) + <span class="string">&quot;MS&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h3><p>​		异步确认发布虽然比前两种方式复杂，但是性价比高，无论是可靠性还是效率都极高，他利用回调函数来达到消息的可靠性传递，这个中间件也是通过函数回调来保证是否投递成功。</p>
<p><img src="https://s2.loli.net/2023/05/08/Ri5UN4bWm2FeIvu.png" alt="流程图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtil.getChannel();</span><br><span class="line">        channel.queueDeclare(queueName, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//发布确认</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *线程安全有序的一个哈希表，适用于高并发的i情况下</span></span><br><span class="line"><span class="comment">         * 1、轻松的将序号与i消息进行关联</span></span><br><span class="line"><span class="comment">         * 2、轻松的批量删除条目 只要给到序号</span></span><br><span class="line"><span class="comment">         * 3、支持高并发</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConcurrentSkipListMap&lt;Long,String&gt; confirmMessages = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//消息成功回调</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (deliveryTag, multiple) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始确认消息:&quot;</span> + deliveryTag+ <span class="string">&quot;----------&quot;</span> + confirmMessages.get(deliveryTag));</span><br><span class="line">            <span class="keyword">if</span>(multiple)&#123;</span><br><span class="line">                ConcurrentNavigableMap&lt;Long, String&gt; longStringConcurrentNavigableMap =</span><br><span class="line">                        confirmMessages.headMap(deliveryTag);</span><br><span class="line">                longStringConcurrentNavigableMap.clear();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                confirmMessages.remove(deliveryTag);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;确认消息:&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//消息失败回调</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1、消息的标记</span></span><br><span class="line"><span class="comment">         * 2、是否为批量确认</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (deliveryTag, multiple) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> confirmMessages.get(deliveryTag);</span><br><span class="line">            System.out.println(<span class="string">&quot;未确认消息:&quot;</span> + message + <span class="string">&quot;:::::::未确认消息tag:&quot;</span> + deliveryTag);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.addConfirmListener(ackCallback,nackCallback);</span><br><span class="line">        <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">            confirmMessages.put(channel.getNextPublishSeqNo(),message);</span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;异步发布确认模式下发送&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个消耗时&quot;</span> + (end - begin) + <span class="string">&quot;MS&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何处理异步未确认的消息"><a href="#如何处理异步未确认的消息" class="headerlink" title="如何处理异步未确认的消息"></a>如何处理异步未确认的消息</h3><p>​		最好的解决办法就是把未确认的消放到一个基于内存的被发布线程访问的队列，比如用ConcurrentLinkedQueue，这个队列在confim callbacks与发布线程之间进行消息传递。</p>
<h3 id="以上3中发布确认速度对比"><a href="#以上3中发布确认速度对比" class="headerlink" title="以上3中发布确认速度对比"></a>以上3中发布确认速度对比</h3><p>​		单独发布消息</p>
<p>​				同步等待确认，简单，但吞吐量非常有限</p>
<p>​		批量发布消息</p>
<p>​				批同步等待确认，简单，合理的吞吐量，一旦出现问题时很难推断出是哪条消息出现问题</p>
<p>​		异步处理</p>
<p>​				最佳性能和资源使用，再出现错误的情况下可以很好地孔子，实现稍复杂。</p>
<h1 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h1><h2 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>​		RabbitMQ消息传递模型的核心思想是：<strong>生产者生产的消息从不会直接发送到队列</strong>。实际上，通过生产者甚至都不知道这些消息传递到了哪些队列中。</p>
<p>​		相反，生产者只能将消息发送到交换机（exchange）,交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如处理收到的消息。是应该把这些消息放到特定的队列还是说把他们放到许多队列还是说应该丢弃它们，这就是由交换机的类型来决定。</p>
<p><img src="https://s2.loli.net/2023/05/10/pUIzWROdLliYAfx.png" alt="交换机"></p>
<h3 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h3><p>类型包含有 直接(direct),主题(topic),标题(headers),扇出(fanout)</p>
<h3 id="无名Exchange"><a href="#无名Exchange" class="headerlink" title="无名Exchange"></a>无名Exchange</h3><p>​		本章及之前对消息进行发送时，并未设置Exchange，但是也可以发送成功，那是因为使用了默认交换机，通过空字符串(“”)进行标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,queueName,<span class="literal">null</span>,message.getBytes());</span><br></pre></td></tr></table></figure>

<p>​		第一个参数是交换机名称空字符串标识默认或无名称交换机：消息能路由发送到队列中其实是由routingKey(bindingKey)绑定的key指定的，如果它存在的话。</p>
<p>​		而对于前面使用的默认交换机，其实就是exchange&#x3D;”” 并且 routingKey&#x3D;queueName的模式进行的绑定。</p>
<h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><p>​		之前的章节使用的都是具有特定名称的队列(例如hello与ack_queue。队列的名称对我们来说至关重要，，我们需要指定我们的消费者去消费哪个队列的消息。</p>
<p>​		每当我们连接到rabbitMQ时，我们都需要一全新的空队列，为此我们可以创建一个具有<strong>随机名称的队列</strong>，或者能让服务器为我们选择一个随机队列名称就更好了。其次<strong>一旦我们断开了消费者的连接，队列将被自动删除。</strong></p>
<p>​		创建临时队列的方式如下</p>
<p>​		String queueName &#x3D; channel.queueDeclare().getQueue();</p>
<p><img src="https://s2.loli.net/2023/05/10/TuonNCfSmGsjyIc.png" alt="临时队列"></p>
<h2 id="绑定-bindings"><a href="#绑定-bindings" class="headerlink" title="绑定(bindings)"></a>绑定(bindings)</h2><p>​		什么是binding呢，binding其实时exchange与queue之间的桥梁他告诉我们exchange和哪个队列进行了绑定绑定关系，比如下图就是X与Q1和Q2进行了绑定。</p>
<p><img src="https://s2.loli.net/2023/05/10/5NB8V3I7DmaMH1X.png" alt="绑定"></p>
<h2 id="Fanout-扇出"><a href="#Fanout-扇出" class="headerlink" title="Fanout(扇出)"></a>Fanout(扇出)</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​		Fanout类型其实非常简单，它是将接收到的消息广播给所有的队列中，服务默认有删除类型交换机。</p>
<p>​		注：其实此类型就是绑定的队列与交换机之间的路由全部一样。</p>
<h3 id="Fanout实战"><a href="#Fanout实战" class="headerlink" title="Fanout实战"></a>Fanout实战</h3><p><img src="https://s2.loli.net/2023/05/10/bHuN7s3L9mWyGo1.png" alt="扇出实战"></p>
<p>消费者1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtil.getChannel();</span><br><span class="line">        <span class="comment">//交换机名称，扇出类型</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//声明一个队列 临时队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待消息接受,把接收到的消息打印到屏幕上&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogs01控制台接收到消息：&quot;</span> + msg);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtil.getChannel();</span><br><span class="line">        <span class="comment">//交换机名称，扇出类型</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">        <span class="comment">//声明一个队列 临时队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">        channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待消息接受,把接收到的消息打印到屏幕上&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogs02控制台接收到消息：&quot;</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtil.getChannel();</span><br><span class="line">        <span class="comment">//交换机名称，扇出类型</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, next.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出：&quot;</span> + next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h2><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>​		上一节中，，通过代码构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节中我们将向其中添加一些特别的功能，比方说我们只让某个消费者订阅发布大的部分消息。例如只把严重消息定向存储到日志文件，同时仍然能在控制台打印所有日志消息。</p>
<p>​		回顾下什么是binings绑定时交换机与队列之间的桥梁关系。可以理解为<strong>队列只对它绑定的交换机的消息感兴趣</strong>。绑定用参数routingKey来表示，也可以称之为binding key,创建绑定我们用代码channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”)；<strong>绑定之后意义由其交换机类型决定</strong>。</p>
<p>Direct Exchange 介绍</p>
<p>​		对上一节的广播消息想做一些改变，例如我们希 望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志 消息避免浪费磁盘空间。Fanout 这种交换类型并不能给我们带来很大的灵活性，它只能进行无意识的 广播，在这里我们将使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的 routingKey 队列中去</p>
<p><img src="https://s2.loli.net/2023/05/10/chTBjCpF4WwRVd3.png" alt="直连模式"></p>
<p>​		在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange， 队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green。</p>
<p>​		在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列 Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p>
<h3 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h3><p><img src="https://s2.loli.net/2023/05/10/3Hq1irJzRvThYXB.png" alt="多重绑定"></p>
<p>​		当然如果 exchange 的绑定类型是 direct，但是<strong>它绑定的多个队列的 key 如果都相同</strong>，在这种情 况下虽然绑定类型是 direct 但是它<strong>表现的就和 fanout 有点类似</strong>了，就跟广播差不多，如上图所示。</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p><img src="https://s2.loli.net/2023/05/10/kBwQyzG2exch91t.png" alt="实战"></p>
<p>消费者1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtil.getChannel();</span><br><span class="line">        <span class="comment">//交换机名称，扇出类型</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//生命一个队列 临时队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;console&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 队列可以进行多重绑定 参数：队列名称，交换机名称，路由</span></span><br><span class="line">        channel.queueBind(<span class="string">&quot;console&quot;</span>, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;console&quot;</span>, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待消息接受,把接收到的消息打印到屏幕上&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogsDirect01控制台接收到消息：&quot;</span> + msg);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;console&quot;</span>, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者2</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect02</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtil.getChannel();</span><br><span class="line">        <span class="comment">//交换机名称，扇出类型</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//生命一个队列 临时队列</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;disk&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        channel.queueBind(<span class="string">&quot;disk&quot;</span>, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待消息接受,把接收到的消息打印到屏幕上&quot;</span>);</span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;ReceiveLogsDirect02控制台接收到消息：&quot;</span> + msg);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;disk&quot;</span>, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DirectLogs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtil.getChannel();</span><br><span class="line">        <span class="comment">//交换机名称，扇出类型</span></span><br><span class="line"><span class="comment">//        channel.exchangeDeclare(EXCHANGE_NAME, &quot;fanout&quot;);</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>, <span class="literal">null</span>, next.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;生产者发出：&quot;</span> + next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Topics"><a href="#Topics" class="headerlink" title="Topics"></a>Topics</h2><h3 id="之前类型的问题"><a href="#之前类型的问题" class="headerlink" title="之前类型的问题"></a>之前类型的问题</h3><p>​		在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是 使用了 direct 交换机，从而有能实现有选择性地接收日志。</p>
<p>​		尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有 info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候 就只能使用 topic 类型</p>
<h3 id="Topic的要求"><a href="#Topic的要求" class="headerlink" title="Topic的要求"></a>Topic的要求</h3><p>​		发送的类型是topic交换机的routingKey不能随意写，必须满足一定的条件，它<strong>必须是一个单词列表，以点号隔开</strong>。这些蚕食可以是任意单词，比如说：”stock.usd.nyse”, “nyse.vmw”,  “quick.orange.rabbit”.这种类型的。当然这个单词列表最多不能超过 255 个字节。</p>
<p>​		在这个规则列表中，其中有两个替换符是大家需要注意的</p>
<p>​			***(星号)可以代替一个单词** </p>
<p>​			<strong>#(井号)可以替代零个或多个单词</strong></p>
<h3 id="Topic匹配案例"><a href="#Topic匹配案例" class="headerlink" title="Topic匹配案例"></a>Topic匹配案例</h3><p>下图绑定关系如下 </p>
<p>​		Q1–&gt;绑定的是</p>
<p>​			中间带 orange 带 3 个单词的字符串(<em>.orange.</em>) </p>
<p>​		Q2–&gt;绑定的是 </p>
<p>​			最后一个单词是 rabbit 的 3 个单词(<em>.</em>.rabbit) </p>
<p>​			第一个单词是 lazy 的多个单词(lazy.#)</p>
<p><img src="https://s2.loli.net/2023/05/10/fVGma6WB23UyQ7F.png" alt="Topic"></p>
<p>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的 </p>
<table>
<thead>
<tr>
<th>交换机</th>
<th>匹配结果</th>
</tr>
</thead>
<tbody><tr>
<td>quick.orange.rabbit</td>
<td>被队列 Q1Q2 接收到</td>
</tr>
<tr>
<td>lazy.orange.elephant</td>
<td>被队列 Q1Q2 接收到</td>
</tr>
<tr>
<td>quick.orange.fox</td>
<td>被队列 Q1 接收到</td>
</tr>
<tr>
<td>lazy.brown.fox</td>
<td>被队列 Q2 接收到</td>
</tr>
<tr>
<td>lazy.pink.rabbit</td>
<td>虽然满足两个绑定但只被队列 Q2 接收一次</td>
</tr>
<tr>
<td>quick.brown.fox</td>
<td>不匹配任何绑定不会被任何队列接收到会被丢弃</td>
</tr>
<tr>
<td>quick.orange.male.rabbit</td>
<td>是四个单词不匹配任何绑定会被丢弃</td>
</tr>
<tr>
<td>lazy.orange.male.rabbit</td>
<td>是四个单词但匹配 Q2</td>
</tr>
</tbody></table>
<p>总结：</p>
<p>在一定情况下Ttopic、direct、franout是可以相互转换的</p>
<p>topic在无模糊匹配时集对应direct模式，而direct在routingKey相同时即为fanout(广播)。</p>
<h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>​		死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，，producer将消息投递到broker或者直接大豆queue里，consumer从queue取出消息进行消费，但某些时候<strong>由于特定的原因导致queue中的某些消息无法被消费</strong>，这样大的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。</p>
<p>​		应用场景：为了保证订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。。还有比如说，用户在商城下单成功并点击去支付后在执行时间内未支付时自动失效。</p>
<h2 id="死信得到来源"><a href="#死信得到来源" class="headerlink" title="死信得到来源"></a>死信得到来源</h2><ol>
<li>消息TTL过期</li>
<li>队列达到最大长度(队列满了，无法再添加数据到mq中)</li>
<li>消息被拒绝(basic.reject或basic.nack)并且requeue&#x3D;true</li>
</ol>
<h2 id="死信实战"><a href="#死信实战" class="headerlink" title="死信实战"></a>死信实战</h2><h3 id="代码架构图"><a href="#代码架构图" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://s2.loli.net/2023/05/13/mfV17GzpbTYh82P.png" alt="死信实战"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtil.getChannel();</span><br><span class="line">        <span class="comment">//死信消息 设置TTL时间 单位时毫秒，</span></span><br><span class="line">        AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties()</span><br><span class="line">                .builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span> + i;</span><br><span class="line">            channel.basicPublish(NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>,properties,message.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者1(启动后关闭，，模拟接收不到消息)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;normal_queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtil.getChannel();</span><br><span class="line">        channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">        <span class="comment">//普通队列设置参数</span></span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-message-ttl&quot;,10000); 可以在生产者指定消息过期时间</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//设置正常消息队列长度</span></span><br><span class="line">        <span class="comment">//arguments.put(&quot;x-max-length&quot;, 6);</span></span><br><span class="line">        <span class="comment">//声明普通队列</span></span><br><span class="line">        channel.queueDeclare(NORMAL_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, arguments);</span><br><span class="line">        <span class="comment">//声死信队列</span></span><br><span class="line">        channel.queueDeclare(DEAD_QUEUE, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        channel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        channel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(msg.equals(<span class="string">&quot;info5&quot;</span>))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01控制台接收到消息：&quot;</span> + msg + <span class="string">&quot;消息被拒绝&quot;</span>);</span><br><span class="line">                channel.basicReject(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer01控制台接收到消息：&quot;</span> + msg);</span><br><span class="line">                channel.basicAck(message.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(NORMAL_QUEUE, <span class="literal">false</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>死信队列消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer02</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;dead_queue&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtil.getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, message) -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Consumer02控制台接收到消息：&quot;</span> + msg);</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(DEAD_QUEUE, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>死信队列流程</p>
<ol>
<li>首先需要对普通&#x2F;死信交换机、队列进行声明、绑定；</li>
<li>要实现死信队列，则需要在普通队列声明时需要指定死信相关的信息，以上代码同时包含了三类死信来源实现<ol>
<li>首先需要设置死信交换机(x-dead-letter-exchange)与死信路由(x-dead-letter-routing-key)；</li>
<li>对于ttl过期可以通过设置交换机参数(x-message-ttl)，也可在生产者发送消息时设置(AMQP.BasicProperties properties &#x3D; new AMQP.BasicProperties()<br>            .builder().expiration(“10000”).build())实现；</li>
<li>队列达到最大长度可通过设置x-max-length，当队列中达到此值后，消息会被放入死信队列；</li>
<li>消息拒绝，可在消息接收到使用basic.reject或basic.nack实现，拒绝后消息也会放入死信队列。</li>
</ol>
</li>
<li>当死信队列中有数据后，死信消费者可以消费消息进行后续逻辑实现。</li>
</ol>
<h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><h2 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h2><p>​		延时队列，队列内部是有序的，最重要的特征就体现在它的延时属性上，，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>订单在十分钟之内未支付则自动取消</li>
<li>新创建的店铺，如果十天之内都没有上传过商品则自动发送消息提醒。</li>
<li>等等等</li>
</ol>
<h2 id="RabbitMQ中大的TTL"><a href="#RabbitMQ中大的TTL" class="headerlink" title="RabbitMQ中大的TTL"></a>RabbitMQ中大的TTL</h2><p>​		TTL是什么呢？TTL是RabbitMQ中一个消息或者队列的属性，表明一条消息或者该队列中的所有消息大的最大存活时间。</p>
<p>​		单位是毫秒。换句话说，如果一个消息设置了TTL属或者进行了设置TTl属性的的队列，那么这条消息如果在TTL设置的时间内没有被消费，则会成为“死信”。如果同时设置了队列的TTL和消息的TTL，那么较小大的那个值将会被使用，有两种方式设置TTL。</p>
<h3 id="消息设置TTL"><a href="#消息设置TTL" class="headerlink" title="消息设置TTL"></a>消息设置TTL</h3><p>​	一种是为消息设置TTL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message,msg -&gt;&#123;</span><br><span class="line">    msg.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="队列设置TTL"><a href="#队列设置TTL" class="headerlink" title="队列设置TTL"></a>队列设置TTL</h3><p>另一种是创建队列的时候设置“x-message-ttl”属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//设置死信交换机</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">//设置死信路由</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line"><span class="comment">//设置过期时间 时间单位ms</span></span><br><span class="line">arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();</span><br></pre></td></tr></table></figure>

<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><p>​		如果设置好了队列的TTL属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列则会放入死信队列)，对于<strong>设置消息的TTL属性，消息即使过期，也不一定会被马上丢弃</strong>，因为消息是否过期是在即将投递给消费者之前判断的，如果当前对队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；另外，需要注意的一点是，如果<strong>不设置TTL表示消息永远不会过期</strong>，如果将<strong>TTL设置为0，则表示除非此时可以直接投递该消息给消费者，否则该消息将会被丢弃</strong>。</p>
<h2 id="队列TTL"><a href="#队列TTL" class="headerlink" title="队列TTL"></a>队列TTL</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p>​		创建两个队列QA和QB，两者分别设置TTL为10s和40s，然后创建一个交换机X和死信交换机Y，，类型均为direct，，创建死信队列QD，绑定关系如下：</p>
<p><img src="https://s2.loli.net/2023/05/13/zLpYWvSdm5stGl6.png" alt="队列TTL"></p>
<p>配置代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">X_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_A</span> <span class="operator">=</span> <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_B</span> <span class="operator">=</span> <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_DEAD_D</span> <span class="operator">=</span> <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">xExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(X_EXCHANGE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">yExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(Y_DEAD_LETTER_EXCHANGE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信路由</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//设置过过期时间 时间单位ms</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//设置死信交换机</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">        <span class="comment">//设置死信路由</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">        <span class="comment">//设置过过期时间 时间单位ms</span></span><br><span class="line">        arguments.put(<span class="string">&quot;x-message-ttl&quot;</span>,<span class="number">40000</span>);</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(arguments).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueD</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_DEAD_D).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueABindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> Exchange exchangeX)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueA).to(exchangeX).with(<span class="string">&quot;XA&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueBBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queueB,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> Exchange exchangeX)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueB).to(exchangeX).with(<span class="string">&quot;XB&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">queueDBindingY</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,<span class="meta">@Qualifier(&quot;yExchange&quot;)</span> Exchange exchangeY)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueD).to(exchangeY).with(<span class="string">&quot;YD&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>消息生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间:&#123;&#125;,发送一条消息&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), message);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自ttl为10s的队列&quot;</span> + message);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自ttl为40s的队列&quot;</span> + message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间:&#123;&#125;,收到死信队列消息:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		通过执行可以发现，第一条消息在10s后变成了死信消息，然后被消费者消费，第二条消息在40s后变成了死信消息，然后被消费掉，这样就实现了一个延时队列。</p>
<p>​		不够这样有一个弊端，那就是<strong>每增加一个新的时间需求，就要新增一个队列</strong>，造成资源浪费。</p>
<h2 id="延时队列优化"><a href="#延时队列优化" class="headerlink" title="延时队列优化"></a>延时队列优化</h2><h3 id="代码架构图-1"><a href="#代码架构图-1" class="headerlink" title="代码架构图"></a>代码架构图</h3><p>​		在这里新增一个队列QC，绑定关系如下，该队列不设置TTL时间</p>
<p><img src="https://s2.loli.net/2023/05/13/JUWQGr1P4Cgucdp.png" alt="优化"></p>
<h3 id="配置文件类修改"><a href="#配置文件类修改" class="headerlink" title="配置文件类修改"></a>配置文件类修改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_C</span> <span class="operator">=</span> <span class="string">&quot;QC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueC</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">//设置死信交换机</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">    <span class="comment">//设置死信路由</span></span><br><span class="line">    arguments.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">    <span class="comment">//设置过过期时间 时间单位,此处不设置队列TTL</span></span><br><span class="line">    <span class="comment">//        arguments.put(&quot;x-message-ttl&quot;,40000);</span></span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(arguments).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">queueCBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> Exchange exchangeX)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queueC).to(exchangeX).with(<span class="string">&quot;XC&quot;</span>).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendExpirationMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> String ttlTime)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间:&#123;&#125;,发送一条时长:&#123;&#125;毫秒 消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), ttlTime, message);</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message,msg -&gt;&#123;</span><br><span class="line">        msg.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置消息TTL弊端"><a href="#设置消息TTL弊端" class="headerlink" title="设置消息TTL弊端"></a>设置消息TTL弊端</h3><p>​		在消息上设置TTL，消息并不会按时“死亡”，因为<strong>TabbitMQ只会检查第一个消息是否过期，如果过期则丢到死信队列，如果第一个消息的延长时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</strong></p>
<h2 id="RabbitMQ插件实现延迟队列"><a href="#RabbitMQ插件实现延迟队列" class="headerlink" title="RabbitMQ插件实现延迟队列"></a>RabbitMQ插件实现延迟队列</h2><p>​		上述问题可以通过mq的延时插实现</p>
<h3 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h3><p>​		在官网上下载 <a href="https://www.rabbitmq.com/community-plugins.html%EF%BC%8C%E4%B8%8B%E8%BD%BD">https://www.rabbitmq.com/community-plugins.html，下载</a> rabbitmq_delayed_message_exchange 插件，然后解压放置到 RabbitMQ 的插件目录。</p>
<p>​		进入 RabbitMQ 的安装目录下的 plgins 目录，执行下面命令让该插件生效，然后重启 RabbitMQ</p>
<p>​		&#x2F;mqinsttallpath&#x2F;rabbitmq_server&#x2F;plugins</p>
<p>​		rabbitmq-plugins enable rabbitmq_delayed_message_exchange</p>
<p><img src="https://s2.loli.net/2023/05/13/F7vwSZLx1niDY8R.png" alt="延时插件"></p>
<h3 id="代码架构图-2"><a href="#代码架构图-2" class="headerlink" title="代码架构图"></a>代码架构图</h3><p>​		在这里新增了一个队列 delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下:</p>
<p><img src="https://s2.loli.net/2023/05/13/mTcRrbl5Wasf6ON.png" alt="架构图"></p>
<h3 id="配置文件类"><a href="#配置文件类" class="headerlink" title="配置文件类"></a>配置文件类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; arguments = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        arguments.put(<span class="string">&quot;x-delayed-type&quot;</span>,<span class="string">&quot;direct&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1.交换机名称</span></span><br><span class="line"><span class="comment">         * 2.交换机类型</span></span><br><span class="line"><span class="comment">         * 3.是否持久化</span></span><br><span class="line"><span class="comment">         * 4.是否自动删除</span></span><br><span class="line"><span class="comment">         * 5.其他参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE,<span class="string">&quot;x-delayed-message&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayedBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue delayedQueue,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/sendDelayedMsg/&#123;message&#125;/&#123;delayedTime&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendExpirationMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message, <span class="meta">@PathVariable</span> Integer delayedTime)</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;当前时间:&#123;&#125;,发送一条延时:&#123;&#125;毫秒 消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), delayedTime, message);</span><br><span class="line">    rabbit Template.convertAndSend(DelayExchangeConfig.DELAYED_EXCHANGE, DelayExchangeConfig.DELAYED_ROUTING_KEY, message, msg -&gt;&#123;</span><br><span class="line">        msg.getMessageProperties().setDelay(delayedTime);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="延迟消息消费者"><a href="#延迟消息消费者" class="headerlink" title="延迟消息消费者"></a>延迟消息消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelaayedQueueConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = DelayExchangeConfig.DELAYED_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间:&#123;&#125;,收到延时消息:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果正常。</p>
<h1 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h1><p>​		在生产环境中由于一些不明原因，导致rabbitmq重启，，在rabbitmq重启期间生产者消息投递失败，导致消息丢失，，需要手都冻处理和恢复。于是，我们开始思考，如何才能进行rabbitmq的消息可靠投递呢？特别是在这样比较极端的情况，rabbitmq集群不可使用的时候，无法投递的消息该如何处理呢？</p>
<h2 id="发布确认（SpringBoot版本）"><a href="#发布确认（SpringBoot版本）" class="headerlink" title="发布确认（SpringBoot版本）"></a>发布确认（SpringBoot版本）</h2><h3 id="发布确认机制方案"><a href="#发布确认机制方案" class="headerlink" title="发布确认机制方案"></a>发布确认机制方案</h3><p><img src="https://s2.loli.net/2023/05/13/524vkRziqJPefpU.png" alt="发布确认"></p>
<h3 id="代码架构图-3"><a href="#代码架构图-3" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://s2.loli.net/2023/05/13/ra1sIQxubB7Htnw.png" alt="代码架构"></p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在配置文件中添加</p>
<p><strong>spring.rabbitmq.publisher-confirm-type&#x3D;correlated</strong></p>
<ul>
<li><p>NONE</p>
<p>禁用发布确认模式，，是默认值</p>
</li>
<li><p>CORRELATED</p>
<p>发布消息成功到交换器后触发回调方法</p>
</li>
<li><p>SIMPLE</p>
<p>经测试有两种效果，，其一效果和CORRELATED值一样会返回回调方法</p>
<p>其二在发布消息成功后使用rabbitTemmplate调用waitForConfirms或者waitForConfirmsOrDie方法等待broker节点返回发送结果，根据返回结果来判断下一步的逻辑，，需要注意的点是waitForConfirmsOrDie方法如果返回false则会关闭channel，接下来无法发送消息到borker</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">192.168.3.83</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">guest</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">guest</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE).durable(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">confirmBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a>消息生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConfirmController</span><span class="params">(RabbitTemplate rabbitTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span> &#123;</span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;发送确认消息：&#123;&#125;&quot;</span>, message);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE, ConfirmConfig.CONFIRM_ROUTING_KEY, message, correlationData);</span><br><span class="line"></span><br><span class="line">        <span class="type">CorrelationData</span> <span class="variable">correlationData2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;发送确认消息：&#123;&#125;&quot;</span>, message);</span><br><span class="line">        rabbitTemplate.convertAndSend(ConfirmConfig.CONFIRM_EXCHANGE + <span class="string">&quot;6&quot;</span>, ConfirmConfig.CONFIRM_ROUTING_KEY + <span class="string">&quot;6&quot;</span>, message, correlationData2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回调接口"><a href="#回调接口" class="headerlink" title="回调接口"></a>回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	交换机确认回调方法，此方法在发送时无论是否发送交换机成功，均会进行回调</span></span><br><span class="line"><span class="comment">        1、发消息 交换机接收到了 回调</span></span><br><span class="line"><span class="comment">        1.1 correlationData 保存回调消息的id及相关消息</span></span><br><span class="line"><span class="comment">        1.2 交换机收到消息 true</span></span><br><span class="line"><span class="comment">        1.3 cause null</span></span><br><span class="line"><span class="comment">        2.发消息 交换机接收失败 回调</span></span><br><span class="line"><span class="comment">        2.1 correlationData 保存回调消息的id及相关消息</span></span><br><span class="line"><span class="comment">        2.2 交换机收到消息 false</span></span><br><span class="line"><span class="comment">        1.3 cause 失败原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;发送交换机成功 id===&#123;&#125;&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;发送交换机失败 id===&#123;&#125;，失败原因是：&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmrQueueConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.CONFIRM_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;当前时间:&#123;&#125;,收到确认消息:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 消息发日志记录</span><br><span class="line">2023-05-13 21:01:54.803  INFO 21940 --- [nio-8080-exec-4] n.o.s.controller.ConfirmController       : 发送确认消息：66666</span><br><span class="line">2023-05-13 21:01:54.804  INFO 21940 --- [nio-8080-exec-4] n.o.s.controller.ConfirmController       : 发送确认消息：66666</span><br><span class="line">#发送成功，，消费者消费日志记录</span><br><span class="line">2023-05-13 21:01:54.805  INFO 21940 --- [ntContainer#0-1] n.o.s.consumer.ConfirmrQueueConsumer     : 当前时间:Sat May 13 21:01:54 CST 2023,收到确认消息:66666</span><br><span class="line"></span><br><span class="line">2023-05-13 21:01:54.806 ERROR 21940 --- [2.168.3.83:5672] o.s.a.r.c.CachingConnectionFactory       : Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange &#x27;confirm.exchange6&#x27; in vhost &#x27;/&#x27;, class-id=60, method-id=40)</span><br><span class="line"># 发布交换机成功回调，日志记录</span><br><span class="line">2023-05-13 21:01:58.310  INFO 21940 --- [nectionFactory4] n.o.s.config.MyCallBack                  : 发送交换机成功 id===1</span><br><span class="line"># 发布交换机失败回调 日志记录</span><br><span class="line">2023-05-13 21:01:57.444  INFO 21940 --- [nectionFactory5] n.o.s.config.MyCallBack                  : 发送交换机失败 id===2，失败原因是：channel error; protocol method: #method&lt;channel.close&gt;(reply-code=404, reply-text=NOT_FOUND - no exchange &#x27;confirm.exchange6&#x27; in vhost &#x27;/&#x27;, class-id=60, method-id=40)</span><br></pre></td></tr></table></figure>

<h2 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h2><h3 id="Mandatory参数"><a href="#Mandatory参数" class="headerlink" title="Mandatory参数"></a>Mandatory参数</h3><p>​		<strong>在仅开启生产者确认机制的情况下，交换机收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，，此时生产者是不知道消息被丢弃这个事件的。</strong>那么如何让无法被路由的消息帮我想办法处理下呢？最起码通知我一声，，我好自己处理啊。通过设置mandatory参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback, RabbitTemplate.ReturnCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * true：</span></span><br><span class="line"><span class="comment">         *  交换机无法将消息进行路由时，会将该消息返回给生产者</span></span><br><span class="line"><span class="comment">         * false：</span></span><br><span class="line"><span class="comment">         *  如果发现消息无法进行路由，则直接丢弃</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        交换机确认回调方法</span></span><br><span class="line"><span class="comment">        1、发消息 交换机接收到了 回调</span></span><br><span class="line"><span class="comment">        1.1 correlationData 保存回调消息的id及相关消息</span></span><br><span class="line"><span class="comment">        1.2 交换机收到消息 true</span></span><br><span class="line"><span class="comment">        1.3 cause null</span></span><br><span class="line"><span class="comment">        2.发消息 交换机接收失败 回调</span></span><br><span class="line"><span class="comment">        2.1 correlationData 保存回调消息的id及相关消息</span></span><br><span class="line"><span class="comment">        2.2 交换机收到消息 false</span></span><br><span class="line"><span class="comment">        1.3 cause 失败原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;发送交换机成功 id===&#123;&#125;&quot;</span>, id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;发送交换机失败 id===&#123;&#125;，失败原因是：&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当消息传递过程中不可达目的地时将消息退回给生产者</span></span><br><span class="line">    <span class="comment">//之后又不可达目的地时才会回退</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;消息:&#123;&#125;被交换机:&#123;&#125;退回，退回原因是：&#123;&#125;，routingKey是：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()), exchange, replyText, routingKey);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>注：需要手动设置rabbitTemplate.setMandatory(true);或者配置文件中社设置spring.rabbitmq.publisher-returns&#x3D;true均可开启。</p>
<h2 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h2><p>​		有了mandatory参数和和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理。但有时候，，我们并不知道该如何处理这些无法路由的消息，最多打个日志，，然后出发报警，，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，，特别当生产者所在大的服务有多台机器得到时候手动副指挥日志和会更加麻烦并且且容易出错。而且色之后mandatory参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？去前面在设置死信队列的文章中，我们提到，可以为队列色湖之私信交换机来存储那些处理失败的消息，可是这些不可路由的消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。在RabbitM中，有一种备交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？备份交换机可以理解为RabbitMQ中交换机的备胎，当我们为某一个交换机声明一个对应的备份交换机时，句实话为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理，通常备份交换机的类型为Fanout,这样能把所有消息都投递到与其帮i的那个的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入则会个队列了&#x2F;当然，我们还可以建立一个报警队列，用对立的消费者来进行监测和报警。</p>
<h3 id="代码架构图-4"><a href="#代码架构图-4" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://s2.loli.net/2023/05/13/XPBKgWlSU7jVJAO.png" alt="备份交换机"></p>
<h3 id="修改配置类"><a href="#修改配置类" class="headerlink" title="修改配置类"></a>修改配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;key1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//备份交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;backup.exchange&quot;</span>;</span><br><span class="line">    <span class="comment">//备份队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;backup.queue&quot;</span>;</span><br><span class="line">    <span class="comment">//报警队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WARNING_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.directExchange(CONFIRM_EXCHANGE).durable(<span class="literal">true</span>)</span><br><span class="line">                .withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">backupExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.fanoutExchange(BACKUP_EXCHANGE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">backupQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">warningQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">backupBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Qualifier(&quot;backupQueue&quot;)</span> Queue backupQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(backupQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">warningBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue warningQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(warningQueue).to(backupExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">confirmBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange confirmExchange,</span></span><br><span class="line"><span class="params">                                  <span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue confirmQueue)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：在声明交换机时设置参数alternate-exchange，值为备份交换机名称即可。</p>
<h3 id="报警消费者"><a href="#报警消费者" class="headerlink" title="报警消费者"></a>报警消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarningQueueConsumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = ConfirmConfig.WARNING_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">        log.info(<span class="string">&quot;WarningQueueConsumer当前时间:&#123;&#125;,收到确认消息:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>当交换机信息发生变化时，需要先将原交换机进行删除，然后再启动进行创建。</p>
<h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><p><img src="https://s2.loli.net/2023/05/13/T9PMAXV5YORk7Ua.png" alt="备份交换机结果"></p>
<p>mandatory参数与备份交换机可以同时配置，如果两者同时开启，则以<strong>备份交换机优先</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://blog.oinbo.cn">Thirteen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://blog.oinbo.cn/2023/04/29/202304292359/">http://blog.oinbo.cn/2023/04/29/202304292359/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://blog.oinbo.cn" target="_blank">陆柒</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></div><div class="post-share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/05/05/202305050036/" title="Redis学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Redis学习笔记</div></div><div class="info-2"><div class="info-item-1">概述​		Remote Dictionary Server(远程字典服务)是完全开源的，使用ANSIC语言编写遵守BSD协议，是一个高性能的Key-Value数据库提供了丰富的数据结构，例如String、Hash、List、Set、SortedSet等等。数据是存在内存中的，同时Redis支持事务、持久化、LUA脚本、发布&#x2F;订阅、缓存淘汰、流技术等多种功能特性提供了主从模式、Redis Sentinel和Redis...</div></div></div></a><a class="pagination-related" href="/2023/04/24/202304240009/" title="Spring Cloud Gateway"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Spring Cloud Gateway</div></div><div class="info-2"><div class="info-item-1">随着微服务开发与使用越来越广泛，单组件服务也越来越多，导致服务的维护变得复杂，试想如果使用nginx作为负载均衡，当服务增加一个就需要重新配置nginx，这样就使得项目的维护成本与难度越来越高，于是网关在微服务开发中就成为了也不可或缺的存。 网关可以作为服务的统一入口，封装应用程序的内部结构，客户端提供统一服务，一些与也无无关的公共逻辑也可以放在网关实现，如认证、鉴权、监控、路由转发等。   本文就Spring Cloud Gateway记录一下我自己的学习笔记。 Spring Cloud Gateway 功能特征 动态路由：能够匹配任何请求属性； 支持路径重写; 集成 Spring Cloud 服务发现功能（Nacos、Eruka）； 可集成流控降级功能（Sentinel、Hystrix）； 可以对路由指定易于编写的 Predicate（断言）和...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Thirteen</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" href="https://github.com/HuangBoo461"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MQ%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">MQ的相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMQ"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是MQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8MQ"><span class="toc-number">1.1.2.</span> <span class="toc-text">为什么使用MQ</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ"><span class="toc-number">1.2.</span> <span class="toc-text">RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">RabbitMQ的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">四大核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">RabbitMQ核心部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E5%90%8D%E8%AF%8D%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.4.</span> <span class="toc-text">各个名词介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.5.</span> <span class="toc-text">安装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hello-World"><span class="toc-number">2.</span> <span class="toc-text">Hello World</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Work-Queues"><span class="toc-number">3.</span> <span class="toc-text">Work Queues</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AE%E8%AE%AD%E5%88%86%E5%8F%91%E6%B6%88%E6%81%AF"><span class="toc-number">3.1.</span> <span class="toc-text">轮训分发消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BA%94%E9%81%93"><span class="toc-number">3.2.</span> <span class="toc-text">消息应道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94"><span class="toc-number">3.2.2.</span> <span class="toc-text">自动应答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">消息应答的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multiple%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-number">3.2.4.</span> <span class="toc-text">Multiple的解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%87%AA%E5%8A%A8%E9%87%8D%E6%96%B0%E5%85%A5%E9%98%9F"><span class="toc-number">3.2.5.</span> <span class="toc-text">消息自动重新入队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%89%8B%E5%8A%A8%E5%BA%94%E7%AD%94%E4%BB%A3%E7%A0%81"><span class="toc-number">3.2.6.</span> <span class="toc-text">消息手动应答代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%BA%94%E7%AD%94%E7%BB%93%E6%9E%9C%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.7.</span> <span class="toc-text">手动应答结果说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.3.</span> <span class="toc-text">RabbitMQ持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.3.2.</span> <span class="toc-text">队列实现持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.3.3.</span> <span class="toc-text">消息实现持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%85%AC%E5%B9%B3%E5%88%86%E5%8F%91"><span class="toc-number">3.3.4.</span> <span class="toc-text">不公平分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%8F%96%E5%80%BC"><span class="toc-number">3.3.5.</span> <span class="toc-text">预取值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4"><span class="toc-number">4.</span> <span class="toc-text">发布确认</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">发布确认原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E7%AD%96%E7%95%A5"><span class="toc-number">4.2.</span> <span class="toc-text">发布确认策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.1.</span> <span class="toc-text">开启发布确认的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-number">4.2.2.</span> <span class="toc-text">单个确认发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-number">4.2.3.</span> <span class="toc-text">批量确认发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-number">4.2.4.</span> <span class="toc-text">异步确认发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E6%9C%AA%E7%A1%AE%E8%AE%A4%E7%9A%84%E6%B6%88%E6%81%AF"><span class="toc-number">4.2.5.</span> <span class="toc-text">如何处理异步未确认的消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8A3%E4%B8%AD%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%80%9F%E5%BA%A6%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.6.</span> <span class="toc-text">以上3中发布确认速度对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">5.</span> <span class="toc-text">交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Exchange"><span class="toc-number">5.1.</span> <span class="toc-text">Exchange</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">5.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.2.</span> <span class="toc-text">交换机类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%8DExchange"><span class="toc-number">5.1.3.</span> <span class="toc-text">无名Exchange</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-number">5.2.</span> <span class="toc-text">临时队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A-bindings"><span class="toc-number">5.3.</span> <span class="toc-text">绑定(bindings)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fanout-%E6%89%87%E5%87%BA"><span class="toc-number">5.4.</span> <span class="toc-text">Fanout(扇出)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.4.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fanout%E5%AE%9E%E6%88%98"><span class="toc-number">5.4.2.</span> <span class="toc-text">Fanout实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Direct-Exchange"><span class="toc-number">5.5.</span> <span class="toc-text">Direct Exchange</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE"><span class="toc-number">5.6.</span> <span class="toc-text">回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%91%E5%AE%9A"><span class="toc-number">5.6.1.</span> <span class="toc-text">多重绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">5.6.2.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Topics"><span class="toc-number">5.7.</span> <span class="toc-text">Topics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%8B%E5%89%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.7.1.</span> <span class="toc-text">之前类型的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topic%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">5.7.2.</span> <span class="toc-text">Topic的要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topic%E5%8C%B9%E9%85%8D%E6%A1%88%E4%BE%8B"><span class="toc-number">5.7.3.</span> <span class="toc-text">Topic匹配案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="toc-number">6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E5%BE%97%E5%88%B0%E6%9D%A5%E6%BA%90"><span class="toc-number">6.2.</span> <span class="toc-text">死信得到来源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E5%AE%9E%E6%88%98"><span class="toc-number">6.3.</span> <span class="toc-text">死信实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">6.3.1.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.2.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="toc-number">7.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.2.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E4%B8%AD%E5%A4%A7%E7%9A%84TTL"><span class="toc-number">7.3.</span> <span class="toc-text">RabbitMQ中大的TTL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%AE%BE%E7%BD%AETTL"><span class="toc-number">7.3.1.</span> <span class="toc-text">消息设置TTL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E8%AE%BE%E7%BD%AETTL"><span class="toc-number">7.3.2.</span> <span class="toc-text">队列设置TTL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.3.3.</span> <span class="toc-text">两者的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97TTL"><span class="toc-number">7.4.</span> <span class="toc-text">队列TTL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">7.4.1.</span> <span class="toc-text">架构图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96"><span class="toc-number">7.5.</span> <span class="toc-text">延时队列优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE-1"><span class="toc-number">7.5.1.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E4%BF%AE%E6%94%B9"><span class="toc-number">7.5.2.</span> <span class="toc-text">配置文件类修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-number">7.5.3.</span> <span class="toc-text">生产者代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AFTTL%E5%BC%8A%E7%AB%AF"><span class="toc-number">7.5.4.</span> <span class="toc-text">设置消息TTL弊端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">7.6.</span> <span class="toc-text">RabbitMQ插件实现延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85"><span class="toc-number">7.6.1.</span> <span class="toc-text">插件安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE-2"><span class="toc-number">7.6.2.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB"><span class="toc-number">7.6.3.</span> <span class="toc-text">配置文件类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">7.6.4.</span> <span class="toc-text">消息生产者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">7.6.5.</span> <span class="toc-text">延迟消息消费者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%AB%98%E7%BA%A7"><span class="toc-number">8.</span> <span class="toc-text">发布确认高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%EF%BC%88SpringBoot%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">发布确认（SpringBoot版本）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%E6%96%B9%E6%A1%88"><span class="toc-number">8.1.1.</span> <span class="toc-text">发布确认机制方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE-3"><span class="toc-number">8.1.2.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">8.1.3.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">8.1.4.</span> <span class="toc-text">添加配置类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85-1"><span class="toc-number">8.1.5.</span> <span class="toc-text">消息生产者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.1.6.</span> <span class="toc-text">回调接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">8.1.7.</span> <span class="toc-text">消息消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-number">8.1.8.</span> <span class="toc-text">结果分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%80%80%E6%B6%88%E6%81%AF"><span class="toc-number">8.2.</span> <span class="toc-text">回退消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mandatory%E5%8F%82%E6%95%B0"><span class="toc-number">8.2.1.</span> <span class="toc-text">Mandatory参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">8.3.</span> <span class="toc-text">备份交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE-4"><span class="toc-number">8.3.1.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">8.3.2.</span> <span class="toc-text">修改配置类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E8%AD%A6%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">8.3.3.</span> <span class="toc-text">报警消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.3.4.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90-1"><span class="toc-number">8.3.5.</span> <span class="toc-text">结果分析</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/07/202308070048/" title="面试题记录">面试题记录</a><time datetime="2023-08-07T00:48:05.000Z" title="发表于 2023-08-07 00:48:05">2023-08-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/07/202308070034/" title="SpringBoot3启动源码解析">SpringBoot3启动源码解析</a><time datetime="2023-08-07T00:34:22.000Z" title="发表于 2023-08-07 00:34:22">2023-08-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/05/202305050036/" title="Redis学习笔记">Redis学习笔记</a><time datetime="2023-05-05T00:36:28.000Z" title="发表于 2023-05-05 00:36:28">2023-05-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/29/202304292359/" title="RabbitMQ学习笔记">RabbitMQ学习笔记</a><time datetime="2023-04-29T23:59:21.000Z" title="发表于 2023-04-29 23:59:21">2023-04-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/24/202304240009/" title="Spring Cloud Gateway">Spring Cloud Gateway</a><time datetime="2023-04-24T00:09:42.000Z" title="发表于 2023-04-24 00:09:42">2023-04-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Thirteen</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'dcc4b208cb6a7654f2a5',
      clientSecret: '038a225dcc46e58448043c07f4cb20bf8542dd87',
      repo: 'huangboo461.github.io',
      owner: 'huangboo461',
      admin: ['huangboo461'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '311d9c9e033de7944c81244c0c557de4'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>